# ADR-0003: Vertical Slice Architecture for Payment and Inventory Services

## Status
Accepted

## Context
Payment and Inventory Services are simpler domains compared to Order Service:
- Payment: Process payment, record transaction, publish outcome event
- Inventory: Reserve stock, allocate/release stock, query stock levels

Hexagonal Architecture (chosen for Order Service) would add unnecessary complexity:
- These services have straightforward workflows (event → business logic → DB write → event publish)
- No need for extensive port/adapter abstraction
- Faster development cycles desired for MVP1

We need a simpler architectural pattern optimized for feature delivery.

## Decision
Implement **Vertical Slice Architecture** for Payment and Inventory Services:

**Principles**:
- Organize code by **feature/use case** rather than technical layers
- Each slice contains all layers needed for that feature (handler, model, repository)
- Shared infrastructure (DB access, Kafka config) extracted to common module

**Package Structure (Payment Service)**:
```
ragna.ecommerce.payment
├── features.processpayment (OrderCreated handler, payment logic, repository)
├── features.refundpayment (OrderFailed handler, refund logic, repository)
├── features.querypayment (REST controller, query repository)
└── infrastructure (MongoDB config, Kafka config)
```

**Package Structure (Inventory Service)**:
```
ragna.ecommerce.inventory
├── features.reserveinventory (OrderCreated handler, reservation logic, repository)
├── features.releaseinventory (OrderFailed handler, release logic, repository)
├── features.allocateinventory (OrderCompleted handler, allocation logic, repository)
├── features.queryinventory (REST controller, query repository)
└── infrastructure (MongoDB config, Kafka config)
```

## Consequences

**Positive**:
- **Simplicity**: Minimal abstraction layers; easier to understand for new developers
- **Speed**: Faster feature development; all code for a feature in one package
- **Cohesion**: Related code (handler, model, repository) co-located
- **Flexibility**: Each slice can evolve independently; no shared domain model constraints

**Negative**:
- Potential code duplication across slices (e.g., MongoDB queries)
- Less enforced separation of concerns; risk of mixing business logic with infrastructure
- Harder to extract shared domain logic if Payment/Inventory become more complex in future

**Risks**:
- Developers may create overly large slices that become mini-monoliths
- Shared infrastructure module grows into a utility dumping ground

**Follow-ups**:
- Establish slice sizing guidelines (max 5 classes per slice)
- Refactor to hexagonal if Payment/Inventory complexity increases in MVP2
- Regularly review shared infrastructure for code that should move into slices
