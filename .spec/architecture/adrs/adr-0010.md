# ADR-0010: PostgreSQL for Order Service, MongoDB for Payment and Inventory

## Status
Accepted

## Context
Each service requires database technology optimized for its domain characteristics:

**Order Service**:
- Transactional SAGA coordination (strict consistency for SAGA state)
- Relational data model (orders have items, 1-to-many relationships)
- Outbox pattern requires transactional guarantees (insert order + outbox event atomically)
- Complex queries (order history by customer, status filtering, date ranges)

**Payment Service**:
- Flexible schema for payment methods (credit card, debit, future: PayPal, crypto)
- Audit trail (append-only transaction log, no updates/deletes)
- High write throughput (payment records created frequently, rarely updated)
- Simple queries (payment by ID, payments by order ID)

**Inventory Service**:
- Document model (products with nested attributes: SKU, warehouse location, stock levels)
- High write throughput (stock updates, reservations, allocations)
- Flexible schema (new product attributes without schema migrations)
- Simple queries (stock by product ID, reservation by order ID)

## Decision
Choose database technology per service domain fit:

**Order Service → PostgreSQL**:
- **Rationale**: ACID transactions required for SAGA state + outbox, relational model fits order/items
- **Schema**: `orders`, `order_items`, `saga_state`, `outbox` tables
- **Deployment**: AWS RDS PostgreSQL (multi-AZ for high availability)

**Payment Service → MongoDB**:
- **Rationale**: Flexible document schema for evolving payment methods, append-only audit trail
- **Schema**: `payments` collection (documents with nested payment method details)
- **Deployment**: MongoDB Atlas (managed service, replica sets for availability)

**Inventory Service → MongoDB**:
- **Rationale**: Document model suits product attributes, high write throughput for stock updates
- **Schema**: `inventory_items`, `reservations` collections
- **Deployment**: MongoDB Atlas (managed service, replica sets for availability)

**Technology Alignment**:
- Team has **strong PostgreSQL expertise** (Order Service)
- Team learning MongoDB (Payment/Inventory Services, lower complexity than Order)
- Managed services (RDS, Atlas) reduce operational burden

## Consequences

**Positive**:
- **Domain Fit**: Each database optimized for service data model and access patterns
- **Performance**: PostgreSQL ACID for Order Service, MongoDB high-throughput writes for Payment/Inventory
- **Flexibility**: MongoDB schema evolution without downtime (add fields to documents)
- **Operational Maturity**: Managed services (RDS, Atlas) provide backups, monitoring, scaling

**Negative**:
- **Operational Complexity**: Two database technologies to learn, monitor, tune
- **Skillset Split**: Team must maintain PostgreSQL + MongoDB expertise
- **Tooling Duplication**: Separate migration tools (Flyway for PostgreSQL, custom scripts for MongoDB)
- **Cost**: Managed services more expensive than self-hosted (acceptable for reduced ops burden)

**Risks**:
- MongoDB transactions (required for inventory reservation atomicity) have performance overhead → validate with load tests
- Team unfamiliar with MongoDB best practices (indexing, sharding) → invest in training

**Follow-ups**:
- Team training: MongoDB indexing, transactions, replica set management
- Load test MongoDB transactions (inventory reservation with stock checks)
- Document schema design patterns (embedding vs referencing) in team wiki
- Monitor MongoDB Atlas costs; evaluate self-hosted if cost becomes issue
