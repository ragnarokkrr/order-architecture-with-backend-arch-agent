# ADR-0002: Hexagonal Architecture for Order Service

## Status
Accepted

## Context
Order Service is the most complex component, responsible for:
- SAGA orchestration and state management
- Integration with multiple downstream services (Payment, Inventory)
- Future integration with external systems (payment gateways, notification services in MVP2)

We need an architectural pattern that:
- Isolates domain logic from infrastructure concerns
- Enables easy substitution of adapters (e.g., switching from local payment to gateway in MVP2)
- Supports comprehensive testing of business rules without infrastructure dependencies

## Decision
Implement **Hexagonal Architecture** (Ports and Adapters pattern) for Order Service:

**Layers**:
- **Domain Layer**: Order aggregate, SAGA state machine, domain events (pure business logic)
- **Application Layer**: Use case orchestration (CreateOrderUseCase, CompleteOrderUseCase)
- **Ports**: Interfaces defining contracts
  - Input ports: Use case interfaces (driven by adapters)
  - Output ports: Repository, event publishing, external service interfaces (driving adapters)
- **Adapters**:
  - Inbound: REST controllers, Kafka event listeners
  - Outbound: JPA repositories, Kafka event publishers, outbox implementation

**Package Structure**:
```
ragna.ecommerce.order
├── adapter.in (REST, Kafka listeners)
├── adapter.out (persistence, event publishing)
├── application.service (use case orchestration)
├── application.port.in (use case interfaces)
├── application.port.out (repository, event interfaces)
├── domain.model (Order aggregate, value objects)
├── domain.saga (SAGA state machine)
└── domain.event (domain events)
```

## Consequences

**Positive**:
- **Testability**: Domain logic testable in isolation with mocked ports
- **Flexibility**: Swap adapters without changing domain (e.g., add payment gateway in MVP2)
- **Clarity**: Clear separation of concerns; domain logic free of Spring/infrastructure annotations
- **Evolvability**: Easy to add new ports for MVP2 features (API Gateway, external notifications)

**Negative**:
- More classes/interfaces compared to simpler architectures (increased boilerplate)
- Learning curve for developers unfamiliar with hexagonal architecture
- Potential over-engineering for simple CRUD operations (mitigated by limiting pattern to Order Service only)

**Risks**:
- Developers may bypass ports and couple domain to infrastructure
- Excessive abstraction layers if ports are too granular

**Follow-ups**:
- Document port/adapter mapping in team wiki
- Enforce hexagonal structure via ArchUnit tests
- Provide code templates for new use cases
