# ADR-0004: Single Database per Service

## Status
Accepted

## Context
Microservices architectures must balance data consistency with service autonomy. Options include:
1. **Shared Database**: All services access common database (anti-pattern in microservices)
2. **Database per Service**: Each service owns its database, no cross-service queries
3. **Hybrid**: Some services share databases for specific bounded contexts

Our system has three distinct bounded contexts:
- Orders (transactional, SAGA coordination)
- Payments (transaction records, audit trail)
- Inventory (stock levels, reservations)

We need clear ownership boundaries to enable independent scaling, schema evolution, and deployment.

## Decision
Implement **Single Database per Service**:

- **Order Service**: PostgreSQL database (`order_db`)
  - Tables: `orders`, `order_items`, `saga_state`, `outbox`
  - Rationale: Transactional guarantees for SAGA state, relational model fits order structure
- **Payment Service**: MongoDB database (`payment_db`)
  - Collections: `payments`
  - Rationale: Schema flexibility for evolving payment methods (gateway integration in MVP2)
- **Inventory Service**: MongoDB database (`inventory_db`)
  - Collections: `inventory_items`, `reservations`
  - Rationale: Document model suits nested item structures, high write throughput for stock updates

**Cross-Service Data Access**:
- Services communicate **only via events** (Kafka)
- No direct database queries across service boundaries
- Services maintain local caches/read models if needed (eventual consistency)

## Consequences

**Positive**:
- **Autonomy**: Each service team controls schema, migrations, performance tuning
- **Scalability**: Databases scale independently based on service load
- **Resilience**: Database failure in one service doesn't impact others
- **Technology Fit**: Choose optimal DB technology per domain (PostgreSQL for orders, MongoDB for payments/inventory)

**Negative**:
- **No Joins**: Cross-service data aggregation requires multiple queries or denormalization
- **Eventual Consistency**: Order status may lag payment/inventory updates
- **Complexity**: SAGA pattern required for distributed transactions
- **Data Duplication**: Services may cache data from other services (e.g., Order Service caches customer ID)

**Risks**:
- Developers may bypass events and query other service databases directly (prevent via network isolation)
- Data inconsistency if events are lost or consumers fail (mitigated by outbox pattern, retries)

**Follow-ups**:
- Enforce database access rules via network policies (Kubernetes NetworkPolicies)
- Implement read models for cross-service queries (CQRS pattern)
- Monitor event consumer lag to detect consistency delays
