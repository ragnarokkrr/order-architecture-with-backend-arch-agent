# ADR-0011: Mono-Repository with Independent Services

## Status
Accepted

## Date
2025-11-25

## Context
The Order Processing System consists of three Spring Boot microservices (Order, Payment, Inventory) that are architecturally independent:
- Each service has its own database (Order: PostgreSQL, Payment/Inventory: MongoDB)
- Services communicate exclusively via Kafka events (no direct binary dependencies)
- Each service can be built, tested, deployed, and scaled independently
- Different architectural patterns per service (Hexagonal for Order, Vertical Slice for Payment/Inventory)

Despite this independence, we must decide on repository organization strategy:

**Mono-repository** (single Git repository):
- All services share one repository with separate module directories
- Common: `/order-service`, `/payment-service`, `/inventory-service`, `/shared-lib`
- Single CI/CD pipeline with conditional service builds

**Multi-repository** (separate Git repositories):
- Each service lives in its own repository
- Shared code distributed via dependency management (Maven artifacts, private registry)
- Independent CI/CD pipelines per service

The decision impacts:
- Code sharing (events schemas, utility libraries, infrastructure-as-code)
- Build/deployment complexity (detect changes per service, coordinate releases)
- Team collaboration (atomic commits across services vs coordinated PRs)
- Refactoring safety (cross-service changes in one commit vs breaking changes across repos)

## Decision
Use a **mono-repository** with independent service builds:

**Repository Structure**:
```
order-processing-system/
├── order-service/
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile
├── payment-service/
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile
├── inventory-service/
│   ├── src/
│   ├── pom.xml
│   └── Dockerfile
├── shared-events/
│   ├── src/main/java/ragna/ecommerce/events/
│   └── pom.xml
├── infrastructure/
│   ├── kubernetes/
│   ├── docker-compose.yml
│   └── terraform/
├── .spec/architecture/
└── pom.xml (parent POM)
```

**Build Strategy**:
- **Maven Multi-Module Project**: Parent POM aggregates service modules
- **Selective Builds**: CI/CD detects changed paths, builds only affected services
- **Independent Versioning**: Each service maintains its own semantic version
- **Shared Library**: `shared-events` module for event schemas (versioned independently)

**Deployment Strategy**:
- **Service-Specific Pipelines**: Separate CI/CD jobs per service (triggered by path changes)
- **Independent Container Images**: Each service produces its own Docker image (tagged with service version)
- **Kubernetes Deployments**: Separate Helm charts per service, deployed independently
- **No Binary Coupling**: Services depend only on Kafka event contracts, not each other's JARs

**Event Schema Sharing**:
- `shared-events` module contains Java POJOs for Kafka events (OrderCreated, PaymentProcessed, etc.)
- Services depend on `shared-events` via Maven (compile-time dependency for type safety)
- **Versioning**: `shared-events` follows semantic versioning; breaking changes require coordination
- **Migration Path**: Future migration to schema registry (ADR-0011 planned) replaces compile-time with runtime schema validation

## Consequences

### Positive

**Code Sharing & Reuse**:
- **Event Schemas**: Single source of truth for Kafka events (`shared-events` module)
- **Infrastructure-as-Code**: Shared Kubernetes manifests, Docker Compose, Terraform modules
- **Utilities**: Common logging, tracing, and Kafka abstractions reused across services
- **Consistency**: Easier to enforce coding standards, Spring Boot version alignment

**Atomic Refactoring**:
- **Cross-Service Changes**: Rename event fields, update all consumers in one commit
- **Safe Evolution**: Breaking changes to event schemas caught at compile time across all services
- **Single PR**: Event schema + consumer changes reviewed together, reducing coordination overhead

**Developer Experience**:
- **Single Clone**: Developers check out one repository, see entire system
- **Unified IDE**: IntelliJ/Eclipse workspace with all services, easy cross-service navigation
- **Simplified Onboarding**: New team members learn system structure from one repository

**Simplified Operations**:
- **Unified CI/CD**: One pipeline definition with conditional service builds (simpler than managing 3+ repos)
- **Consistent Tooling**: Shared Maven plugins, Dockerfile patterns, Kubernetes base templates
- **Centralized Documentation**: Architecture docs (`.spec/architecture/`) alongside code

### Negative

**Build Complexity**:
- **Change Detection**: CI/CD must detect which service changed to avoid rebuilding all services on every commit
- **Longer Builds**: Full repository clone larger than single-service repos (mitigated with sparse checkouts, build caching)
- **Dependency Confusion**: Developers may accidentally introduce binary dependencies between services (requires vigilance, architecture tests)

**Coordination Overhead**:
- **Merge Conflicts**: Multiple teams working on different services in same repo may collide on `pom.xml` or shared files
- **Branch Management**: Feature branches may mix changes across multiple services (requires discipline to scope branches per service)
- **Release Tagging**: Need convention for service-specific tags (e.g., `order-service-v1.2.0`, `payment-service-v1.0.1`)

**Shared Library Risk**:
- **Coupling via shared-events**: Breaking changes to `shared-events` force all services to update simultaneously (violates independent deployment)
- **Versioning Complexity**: Services may depend on different versions of `shared-events` (Maven dependency hell)
- **Migration Path**: Eventually migrate to schema registry (Confluent, Apicurio) to decouple event schemas from compile-time dependencies

**Perceived Monolith**:
- **Architectural Vigilance**: Mono-repo may tempt developers to create direct service-to-service dependencies (requires code reviews, architecture tests)
- **Deployment Discipline**: Team must resist urge to deploy all services together (defeats microservices benefits)

### Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|-----------|
| Accidental binary coupling (service imports another service's classes) | Medium | High | Maven Enforcer Plugin rules (ban cross-service dependencies), ArchUnit tests |
| CI/CD builds all services on every commit (slow feedback) | High | Medium | Path-based triggers in CI/CD (build only changed services) |
| `shared-events` becomes bottleneck for independent deployments | Medium | High | Version `shared-events` carefully, maintain backward compatibility, migrate to schema registry in MVP2 |
| Merge conflicts in shared files (pom.xml, docker-compose.yml) | Medium | Low | Feature branches scoped to single service, frequent merges to develop |

### Alternatives Considered

**Alternative 1: Multi-Repository (Separate Repos per Service)**
- **Pros**: True independence (no accidental coupling), clearer ownership boundaries, simpler CI/CD per repo
- **Cons**: Event schema coordination difficult (duplicate POJOs or versioned artifacts), cross-service refactoring requires synchronized PRs, harder to onboard new developers
- **Rejected**: Coordination overhead outweighs independence benefits for MVP1 with single team

**Alternative 2: Mono-Repo with Polyglot Services (Gradle + Maven)**
- **Pros**: Flexibility to use different build tools per service
- **Cons**: Tooling inconsistency, harder to share build configurations, team must learn multiple build systems
- **Rejected**: Team standardized on Maven; no requirement for polyglot builds in MVP1

**Alternative 3: Mono-Repo with Bazel/Gradle Multi-Project**
- **Pros**: Better incremental builds, advanced caching
- **Cons**: Steeper learning curve than Maven, less Spring Boot ecosystem integration
- **Rejected**: Team expertise in Maven; Bazel/Gradle benefits not justified for 3 services

## Follow-ups

**Immediate Actions**:
- Configure Maven Enforcer Plugin to ban cross-service module dependencies (e.g., `order-service` cannot import `payment-service` classes)
- Implement path-based CI/CD triggers (GitHub Actions: `on.push.paths` filtering)
- Establish branch naming convention: `feature/<service>/<description>` (e.g., `feature/order-service/add-cancellation`)
- Write ArchUnit tests to enforce architectural boundaries (services may not import each other)

**MVP2 Enhancements**:
- Migrate event schemas from `shared-events` JAR to Confluent Schema Registry (ADR-0011 planned)
- Evaluate Bazel for faster incremental builds if mono-repo grows beyond 5 services
- Implement Git sparse checkout for developers working on single service
- Add Renovate bot for automated dependency updates across services

**Documentation**:
- Update CONTRIBUTING.md with mono-repo guidelines (branch scoping, build commands per service)
- Document Maven module structure in README.md
- Add "Architecture Tests" section to testing guide (ArchUnit rules for dependency enforcement)
